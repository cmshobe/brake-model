'''
Charlie Shobe
May 26th, 2017

BRAKE: Blocky River And Knickpoint Evolution

Changed in structure and pared down for BMI at CSDMS BMI hackathon 26-May-2017
'''
#Packages:
from __future__ import division
import numpy as np
import scipy.special as sp
import ruamel_yaml as yaml
import sys
import os
np.set_printoptions(threshold=np.inf)

class Brake(object):

    def __init__(self, config_file=None):
        "Initialize the BRaKE model"
        
        if config_file is not None:
            with open(config_file, 'r') as fp:
                parameters = yaml.load(fp)
            for key, value in parameters.items():
                setattr(self, key, value)
        else:
            print "No YAML file found. Running with defaults."
            self.n_cells = 100.
            self.dx = 100.
            self.delay_timescale = 10000.
            self.time_step = 10.
            self.time_to_run = 200000.
            self.bl_drop = 0.00005
            self.bed_k = 1.0e-6
            self.block_k = 1.0e-6
            self.gamma = 1.0
            self.side_length = 4.0
            self.z_0 = 0.1
            self.bed_tau_c = 0.
            self.block_tau_c = 0.
            self.channel_width = 10.
            self.mean_discharge = 15.0
            self.discharge_variability = 0.5
            self.suffix = '1'
            self.recording_interval = 1000.

        self.q = 0.0  # provide initial value
            
        self.calculate_timing_and_recording_vars(self.recording_interval, 
                                                 self.time_to_run, 
                                                 self.time_step, 
                                                 self.bl_drop, 
                                                 self.delay_timescale)
        self.instantiate_common_constants()        
        self.initial_slope = .001 #initial bed slope at each point (m/m)
        starting_dist = 0
        starting_height_adjustment = 10 #starting elev of base of profile [m]
        number_of_pieces = 0 #This is how many pieces are initially distributed
        cubes = 0 #how many cubes? tracked as 0's
        self.instantiate_tracking_matrix(number_of_pieces, self.gamma, cubes, 
                                         starting_dist)
        
        #Shear stress formulation parameters:
        self.set_shear_stress_params(self.bed_k, self.block_k, self.bed_tau_c, 
                                     self.block_tau_c)
        
        #user-defined variables relating to bed layering
        self.define_cell_centers_and_edges(self.n_cells, self.dx, 
                                           self.initial_slope, 
                                           starting_height_adjustment)
        
        #instantiate arrays that change with each time_step
        self.instantiate_single_dt_arrays(self.n_cells, self.initial_slope, 
                                          self.surface_elev)
        
        #instantiate record-keeping arrays
        self.instantiate_record_keeping_arrays(self.time_to_run, 
                                               self.recording_interval, 
                                               self.number_records, 
                                               self.n_cells, 
                                               self.surface_elev_array, 
                                               self.slope)
        
        #set roughness calculation parameters (for roughness generated by bed, not blocks)
        self.set_roughness_depth_calc_params(self.z_0)        
        
        #instantiate counters for loops
        self.instantiate_counting_parameters()

        #calculate initial values of arrays such as block_count_record and cover_frac_record
        self.calculate_initial_array_values(number_of_pieces, self.x_array, 
                                            self.dx, self.channel_width, 
                                            self.side_length)        

    def update(self):
        self.time += self.time_step
        self.run_count += 1
        baselevel_drop = self.baselevel_drop_annual[self.run_count - 1]
        weibull_scale = self.mean_discharge / \
            sp.gamma(1 + (1 / self.discharge_variability))
        q_volume = weibull_scale * np.random.weibull(self.discharge_variability)
        self.q = q_volume / self.channel_width
        
        for x in self.x_array: #spatial loop        
            #allow rockfall to put in new blocks
            num_new_blocks = self.calc_num_new_blocks(x)
            self.track_new_blocks(num_new_blocks, x)
        
            #now, need to redo is_block, is_boulder, etc
            is_block_in_cell = (self.tracking_mat[0:self.for_slicing, 0] >= \
                self.upstream_edges_of_cell[x]) & \
                (self.tracking_mat[0:self.for_slicing, 0] < \
                self.downstream_edges_of_cell[x]) #!

            #calculate flow depth and flow velocity using VPE
            self.calc_flow_depth_and_velocity(x, is_block_in_cell)   
            #calc cover frac so it is using same information as roughness 
            self.calc_cover_frac(is_block_in_cell, x)
        #erode the bed (Fastscape-style algorithm)
        self.erode_bed(baselevel_drop, self.n_cells)
            
        for x in self.x_array: #spatial loop  
            self.calc_force_balance(is_block_in_cell, self.flow_depth[x], 
                                    self.flow_velocity[x], x)
            
            #calculate change in cover fraction based on blocks that moved
            is_block_in_cell = (self.tracking_mat[0:self.for_slicing, 0] >= \
                self.upstream_edges_of_cell[x]) & \
                (self.tracking_mat[0:self.for_slicing, 0] < \
                self.downstream_edges_of_cell[x]) #!
            if np.isnan(np.sum(is_block_in_cell)):
                print is_block_in_cell
                print self.tracking_mat[:, 1] #!
                sys.exit("NAN FOUND IN IS_BLOCK ARRAY-- KILLING MODEL")
            #abrade blocks with excess shear stress
            self.erode_blocks(is_block_in_cell, x)   

            #get size classes of blocks in cells
            self.get_block_size_classes(is_block_in_cell, x)
        
        #track vertical erosion to keep incision rate matrix up-to-date
        self.track_vertical_erosion()
        
        #print model progress to screen at given intervals
        #self.display_model_progress()
        
        #update slope for next iteration (downwind scheme)
        self.update_slope()

        #update record keeping arrays   
        if np.remainder(self.run_count, (self.recording_interval / \
            self.time_step)) == 0: #
            self.update_record_keeping_arrays()
        else:
            pass
        
        self.delete_eroded_or_gone_blocks()
            
    def finalize(self):
        #once everything has run, spit out arrays as .npy binaries
        np.save('time_record_' + self.suffix, self.time_record)
        np.save('elev_record_' + self.suffix, self.surface_elev_record)
        np.save('slope_record_' + self.suffix, self.slope_record)
        np.save('block_count_record_' + self.suffix, self.block_count_record)
        np.save('cover_frac_record_' + self.suffix, self.cover_frac_record)
        np.save('time_avg_inc_rate_record_' + self.suffix, 
                self.time_avg_inc_rate_record)
        np.save('uncorrected_tau_record_' + self.suffix, 
                self.uncorrected_tau_record)
        np.save('corrected_tau_record_' + self.suffix, 
                self.corrected_tau_record)
        np.save('zero_to_one_' + self.suffix, self.zero_to_one)
        np.save('one_to_two_' + self.suffix, self.one_to_two)
        np.save('two_to_three_' + self.suffix, self.two_to_three)
        np.save('three_to_four_' + self.suffix, self.three_to_four)
        np.save('four_to_five_' + self.suffix, self.four_to_five)
        np.save('five_to_six_' + self.suffix, self.five_to_six)
        np.save('six_to_seven_' + self.suffix, self.six_to_seven)
        np.save('seven_to_eight_' + self.suffix, self.seven_to_eight)
        np.save('eight_to_nine_' + self.suffix, self.eight_to_nine)
        np.save('nine_to_ten_' + self.suffix, self.nine_to_ten)
    
    def calc_shear_stress_with_roughness(self, pre_adjusted_tau, tracking_mat, is_block_in_cell, drag_cube, flow_depth, dx, roughness_height, slicing_index, cell):
        blocks_above_flow = (is_block_in_cell) #& (tracking_mat[0:slicing_index, 2] >= flow_depth)        
        a1 = 6.5 #ferguson 2007
        a2 = 2.5 #ferguson 2007        
        if np.count_nonzero(blocks_above_flow) == 0:
            sigma_d_blocks = 0
        else:
            blocks_above_flow = (is_block_in_cell) #& (tracking_mat[0:slicing_index, 2] >= flow_depth)
            beta = (a1 * (flow_depth / roughness_height)) / np.power(np.power(flow_depth / roughness_height, 5 / 3) + np.power(a1 / a2, 2), 1/2)
            avg_diam_blocks = np.average(tracking_mat[0:slicing_index, 1][blocks_above_flow]) #!
            submerged_block = (is_block_in_cell) & (tracking_mat[0:slicing_index, 1] < flow_depth)#!
            emergent_block = (is_block_in_cell) & (tracking_mat[0:slicing_index, 1] >= flow_depth)#!
            tracking_mat[0:slicing_index, 3][submerged_block] = tracking_mat[0:slicing_index, 1][submerged_block]#!
            tracking_mat[0:slicing_index, 3][emergent_block] = flow_depth           #! 
            avg_submerged_height_blocks = np.average(tracking_mat[0:slicing_index, 3][is_block_in_cell]) #!
            avg_spacing_blocks =  dx / np.count_nonzero(blocks_above_flow)
            sigma_d_blocks = (1 / 2) * drag_cube * np.power(beta, 2) *(avg_submerged_height_blocks * avg_diam_blocks / np.power(avg_spacing_blocks, 2))
        self.sigma_d_array[cell] = sigma_d_blocks
        adjusted_shear_stress = pre_adjusted_tau / (1 + sigma_d_blocks)
        return adjusted_shear_stress
        
    def roughness_bisection(self, q, s, d, g):
        if s <= 0:
            os.system("rm results.out")
            os.system("touch results.out")
            with open("results.out", "a") as f: 
                f.write('FAIL\n') 
            sys.exit("NEGATIVE SLOPE-- KILLING MODEL")
        else:
            pass
        a1 = 6.5
        a2 = 2.5
        coef_1 = (g * s * np.power(a1, 2)) / (np.power(q, 2) * np.power(d, 2))
        coef_2 = 0.0
        coef_3 = -1 / np.power(d, 5 / 3)
        coef_4 = -np.power(a1 / a2, 2)
        coef_array = np.array([coef_1, coef_2, coef_3, coef_4])
        roots = np.roots(coef_array)
        is_real = np.isreal(roots)
        root = np.real(roots[is_real])[0]
        h = np.power(root, 3 / 5)
        if np.isnan(np.sum(h)):
            print h
            sys.exit("NAN FOUND IN ROOT'S H-- KILLING MODEL")
        return h
        
    def calculate_timing_and_recording_vars(self, recording_interval, time_to_run, time_step, bl_drop, delay_timescale):
        self.number_iterations = time_to_run / time_step
        self.number_records = np.int(time_to_run / recording_interval)
        self.baselevel_drop_annual = np.repeat(bl_drop, self.number_iterations)
        mem_time_steps = np.int(delay_timescale / self.time_step) #whole number of years
        self.incision_memory = np.zeros((mem_time_steps, self.n_cells))
        
    def instantiate_common_constants(self):  
        np.random.seed(50) #TURN THIS LINE ON TO ELIMINATE INHERENT VARIABILITY
        self.dens_water = 1000 #kg/m^3
        self.dens_sediment = 2650 #kg/m^3
        self.g = 9.81 #acceleration due to gravity (m/s^2)
        self.drag_cube = .8 #from Carling 1998
        self.coeff_static_fric = .6 #from Carling 1998
        
    def set_shear_stress_params(self, bed_k, block_k, tau_c, tau_c_block):
        self.ke_br_bed = bed_k #bedrock is not easy to erode obviously
        self.ke_br_block = block_k
        self.a_br = 1 #bedrock
        self.tau_c_br = tau_c #pascals. bedrock detachment critical shear stress
        self.tau_c_block = tau_c_block
        
    def set_roughness_depth_calc_params(self, z_0):
        self.tolerance = .001 #1 mm
        self.z_0 = z_0 #roughness height NEED TO MAKE THIS DEPENDENT ON SED SIZE DISTRIBUTION
        self.upper_test_lim = 10000 #upper q limit to test e.g. maximum possible flow height
        self.lower_test_lim = 0 #lowest possible flow height
        
    def define_cell_centers_and_edges(self, n_cells, dx, initial_slope, starting_height_adjustment):        
        cell_indices = np.arange(n_cells, dtype = np.float64)
        self.x_array = np.arange(0, n_cells, 1)
        self.cell_centers = (cell_indices * dx) + (dx / 2)
        self.upstream_edges_of_cell = self.cell_centers - (dx / 2)
        self.downstream_edges_of_cell = self.cell_centers + (dx / 2)
        self.surface_elev = -initial_slope * cell_indices * dx + starting_height_adjustment #starting surface elevation (m)
    
    def instantiate_tracking_matrix(self, number_of_pieces, gamma, cubes, starting_dist):    
        if number_of_pieces > 0:
            if gamma == 0:
                self.tracking_mat = np.zeros((number_of_pieces, 4), dtype = np.float64)#!
            else:
                self.tracking_mat = np.zeros((number_of_pieces * 1000, 4), dtype = np.float64) #able to track 6 attributes #!
        else:
            self.tracking_mat = np.zeros((100000, 4), dtype=np.float64) #!
        self.tracking_mat[:, :] = np.nan #THIS IS SO THAT I CAN DISTINGUISH UN-ENTERED VALUES FROM ACTUAL ZEROS
        self.tracking_mat[0:number_of_pieces, 0] = starting_dist #starting distance #!
        self.tracking_mat[0:cubes + 1, 1] = self.side_length #!
        self.tracking_mat[0:cubes + 1, 2] = np.power(self.tracking_mat[0:cubes + 1, 1], 3) #!
        self.tracking_mat[0:cubes + 1, 3] = 0#np.nan #TO BE USED FOR SUBMERGENCE/EMERGENCE #!
        self.cover_frac_array = np.zeros(self.n_cells, dtype = np.float64)
        self.tracking_mat[0:number_of_pieces, 0] = np.random.random_integers(0, 99 * self.dx, sum(~np.isnan(self.tracking_mat[:, 0]))) #!
        
    def instantiate_single_dt_arrays(self, n_cells, initial_slope, surface_elevation):
        self.slope = np.zeros(n_cells, dtype = np.float64)
        self.flow_depth = np.zeros(n_cells, dtype = np.float64)
        self.flow_velocity = np.zeros(n_cells, dtype = np.float64)
        self.surface_elev_array = np.zeros(n_cells, dtype = np.float64)
        self.old_surf_elev_array = np.zeros(n_cells, dtype = np.float64)   
        self.sigma_d_array = np.zeros(n_cells, dtype = np.float64)   
        self.uncorrected_tau_array = np.zeros(n_cells, dtype = np.float64)
        self.corrected_tau_array = np.zeros(n_cells, dtype = np.float64)        
        self.time_avg_inc_rate_array = np.zeros(n_cells, dtype = np.float64)
        self.blocks_in_cells = np.zeros(n_cells, dtype=np.float64)
        self.zero_to_one_temp = np.zeros(n_cells, dtype=np.float64)
        self.one_to_two_temp = np.zeros(n_cells, dtype=np.float64)
        self.two_to_three_temp = np.zeros(n_cells, dtype=np.float64)
        self.three_to_four_temp = np.zeros(n_cells, dtype=np.float64)
        self.four_to_five_temp = np.zeros(n_cells, dtype=np.float64)
        self.five_to_six_temp = np.zeros(n_cells, dtype=np.float64)
        self.six_to_seven_temp = np.zeros(n_cells, dtype=np.float64)
        self.seven_to_eight_temp = np.zeros(n_cells, dtype=np.float64)
        self.eight_to_nine_temp = np.zeros(n_cells, dtype=np.float64)
        self.nine_to_ten_temp = np.zeros(n_cells, dtype=np.float64)
        self.record_count = 0
        self.slope[:] = initial_slope
        self.old_surf_elev_array[:] = surface_elevation
        self.surface_elev_array[:] = surface_elevation
        
    def instantiate_record_keeping_arrays(self, time_to_run, record_time, number_records, n_cells, surface_elev_array, slope):
        self.time_record = np.arange(0, time_to_run + record_time, record_time) #records time
        self.surface_elev_record = np.zeros((number_records + 1, n_cells), dtype = np.float64) #records surface elevation
        self.slope_record = np.zeros((number_records + 1, n_cells), dtype = np.float64) #records slope
        self.block_count_record = np.zeros((number_records + 1, n_cells), dtype = np.float64) #records number of blocks in each cell
        self.cover_frac_record = np.zeros((number_records + 1, n_cells), dtype = np.float64) #records cover fraction
        self.time_avg_inc_rate_record = np.zeros((number_records + 1, n_cells), dtype = np.float64)        
        self.uncorrected_tau_record = np.zeros((number_records + 1, n_cells), dtype = np.float64)
        self.corrected_tau_record = np.zeros((number_records + 1, n_cells), dtype = np.float64)
        #arrays for grain size
        self.zero_to_one = np.zeros((number_records + 1, n_cells), dtype = np.float64)       
        self.one_to_two = np.zeros((number_records + 1, n_cells), dtype = np.float64)
        self.two_to_three = np.zeros((number_records + 1, n_cells), dtype = np.float64)
        self.three_to_four = np.zeros((number_records + 1, n_cells), dtype = np.float64)
        self.four_to_five = np.zeros((number_records + 1, n_cells), dtype = np.float64)
        self.five_to_six = np.zeros((number_records + 1, n_cells), dtype = np.float64)
        self.six_to_seven = np.zeros((number_records + 1, n_cells), dtype = np.float64)
        self.seven_to_eight = np.zeros((number_records + 1, n_cells), dtype = np.float64)
        self.eight_to_nine = np.zeros((number_records + 1, n_cells), dtype = np.float64)
        self.nine_to_ten = np.zeros((number_records + 1, n_cells), dtype = np.float64)
        #initial values
        self.time_record[0] = 0
        self.surface_elev_record[0, :] = surface_elev_array
        self.slope_record[0, :] = slope
        
    def instantiate_counting_parameters(self):
        self.time = 0
        self.run_count = 0
        self.blocks = 0
        
    def calculate_initial_array_values(self, number_of_pieces, x_array, dx, dy, side_length):
        self.for_slicing = number_of_pieces + 1
        for x in x_array:
            self.is_block_in_cell = (self.tracking_mat[0:self.for_slicing, 0] >= self.upstream_edges_of_cell[x]) & (self.tracking_mat[0:self.for_slicing, 0] < self.downstream_edges_of_cell[x]) #!
            block_cover = sum(np.power(self.tracking_mat[0:self.for_slicing, 1][self.is_block_in_cell], 2)) #area covered by blocks
            num_starting_blocks = sum(self.tracking_mat[0:self.for_slicing, 1][self.is_block_in_cell]) / side_length #!
            cover_frac = block_cover / (dx * dy) #how much of cell is COVERED by big bits
            self.cover_frac_array[x] = 1 - np.exp(-cover_frac)
            self.block_count_record[0, x] = num_starting_blocks
            self.cover_frac_record[0, x] = self.cover_frac_array[x]
        
    def calc_num_new_blocks(self, x):
        mean_incision_rate = np.mean(self.incision_memory[:, x])
        self.time_avg_inc_rate_array[x] = mean_incision_rate
        lam_rockfall = mean_incision_rate * self.gamma #GAMMA CONTROLS RATE OF BLOCK INPUT
        num_new_blocks = int(np.random.poisson(lam_rockfall * self.time_step, 1)) #number of new pieces
        return num_new_blocks
        
    def track_new_blocks(self, num_new_blocks, x):
        for new in range(0, num_new_blocks):
            self.blocks += 1
            try:
                next_entry = max(max(np.where(np.isfinite(self.tracking_mat[:, 0])))) + 1 #adding one for next open entry #!
            except ValueError:
                next_entry = 0
            self.for_slicing = next_entry + 1 #b/c when you slice it takes the one before the end                
            if self.for_slicing >= self.tracking_mat.shape[0]:
                addition = np.zeros((1000, 4), dtype = np.float64) #!
                addition[:, :] = np.nan
                self.tracking_mat = np.concatenate((self.tracking_mat, addition))
            else:
                pass
            self.tracking_mat[next_entry, 0] = self.cell_centers[x] #piece is dropped in at center of cell #!
            self.tracking_mat[next_entry, 1] = self.side_length #!
            self.tracking_mat[next_entry, 2] = np.power(self.tracking_mat[next_entry, 2], 3) #calculate volume #!
    
    def calc_flow_depth_and_velocity(self, x, is_block_in_cell):
        h = self.roughness_bisection(self.q, self.slope[x], self.z_0, self.g)  
        if np.isnan(np.sum(h)):
            print h
            sys.exit("NAN FOUND IN FLOW DEPTH-- KILLING MODEL")
        v = self.q / h
        tau_initial = self.dens_water * self.g * h * self.slope[x] #shear stress at each node(Pa)
        self.uncorrected_tau_array[x] = tau_initial  
        if np.isnan(np.sum(self.uncorrected_tau_array)):
            print self.uncorrected_tau_array
            sys.exit("NAN FOUND IN UNCORRECTED TAU-- KILLING MODEL")                     
        tau = self.calc_shear_stress_with_roughness(tau_initial, self.tracking_mat, is_block_in_cell, self.drag_cube, h, self.dx, self.z_0, self.for_slicing, x)
        self.corrected_tau_array[x] = tau
        if np.isnan(np.sum(self.corrected_tau_array)):
            print self.corrected_tau_array
            sys.exit("NAN FOUND IN CORRECTED TAU-- KILLING MODEL")

        self.flow_depth[x] = h
        self.flow_velocity[x] = v
        return (h, v, tau)
        
    def erode_bed(self, baselevel_drop, n_cells):
        excess_tau = self.corrected_tau_array[0:-1] - self.tau_c_br
        self.surface_elev_array[-1] -= (baselevel_drop * self.time_step) #adjust baselevel node
        for cell in range(n_cells - 2, -1, -1):
            if excess_tau[cell] <= 0:
                pass #new elev is the same as old b/c no erosion
            else:
                f_open = 1 - self.cover_frac_array[cell]  
                f_open = f_open.clip(min=0)
                self.surface_elev_array[cell] = (self.surface_elev_array[cell] + \
                    (self.surface_elev_array[cell + 1] * f_open * self.ke_br_bed * \
                    self.dens_water * self.g * self.flow_depth[cell] * self.time_step / \
                    (self.dx * (1 + self.sigma_d_array[cell]))) + (self.time_step * f_open * \
                    self.ke_br_bed * self.tau_c_br)) / (1 + (f_open * self.ke_br_bed * \
                    self.dens_water * self.g * self.flow_depth[cell] * self.time_step / \
                    (self.dx * (1 + self.sigma_d_array[cell]))))
        if np.isnan(np.sum(self.surface_elev_array)):
            print self.surface_elev_array
            sys.exit("NAN FOUND IN ELEV ARRAY-- KILLING MODEL")
                
    def calc_force_balance(self, is_block_in_cell, h, v, x):
        lam_hop = (1. / 365 / 24 / 3600) #average rate of motion = 1 grain diameter per year   
        drag_force = np.zeros(len(self.tracking_mat[0:self.for_slicing, 0]), dtype = np.float64) #!
        weight_force = np.zeros(len(self.tracking_mat[0:self.for_slicing, 0]), dtype = np.float64) #!
        shear_stress_force = np.zeros(len(self.tracking_mat[0:self.for_slicing, 0]), dtype = np.float64) #!
        hop_length = np.zeros((len(self.tracking_mat[0:self.for_slicing, 0]))) #!
        
        #motion of blocks
        submerged_block = (is_block_in_cell) & (self.tracking_mat[0:self.for_slicing, 1] < h)#!
        emergent_block = (is_block_in_cell) & (self.tracking_mat[0:self.for_slicing, 1] >= h)#!
        self.tracking_mat[0:self.for_slicing, 3][submerged_block] = self.tracking_mat[0:self.for_slicing, 1][submerged_block]#!
        self.tracking_mat[0:self.for_slicing, 3][emergent_block] = h#!
        
        #FORCE BALANCE
        friction_angle = np.radians(20)
        drag_force[is_block_in_cell] = (1. / 2) * self.drag_cube * \
            self.tracking_mat[0:self.for_slicing, 3][is_block_in_cell] * \
            self.tracking_mat[0:self.for_slicing, 1][is_block_in_cell] * \
            self.dens_water * np.power(v, 2) #!
        weight_force[is_block_in_cell] = self.g * ((self.dens_sediment - \
            self.dens_water) * (self.tracking_mat[0:self.for_slicing, 3][is_block_in_cell] * \
            np.power(self.tracking_mat[0:self.for_slicing, 1][is_block_in_cell], 2)) + \
            self.dens_sediment * (self.tracking_mat[0:self.for_slicing, 1][is_block_in_cell] - \
            self.tracking_mat[0:self.for_slicing, 3][is_block_in_cell])\
            * np.power(self.tracking_mat[0:self.for_slicing, 1][is_block_in_cell], 2))#!
        shear_stress_force[emergent_block] = 0         
        shear_stress_force[submerged_block] = (self.dens_water * self.g * \
            self.slope[x] * (h - self.tracking_mat[0:self.for_slicing, 3][submerged_block])) * \
            np.power(self.tracking_mat[0:self.for_slicing, 1][submerged_block], 2)  #!        
        lift_force = 0.85 * (drag_force + shear_stress_force)
        slope_rad = np.arctan(self.slope[x]) 
        total_motion_force = weight_force * np.sin(slope_rad) + shear_stress_force + drag_force
        total_resist_force = (weight_force * np.cos(slope_rad) - lift_force) * np.tan(friction_angle)

        is_moving_block = (total_motion_force > total_resist_force) & (is_block_in_cell)
        not_moving_block = (total_motion_force <= total_resist_force) & (is_block_in_cell)
        hop_length[is_moving_block] = np.random.poisson(lam_hop * self.time_step, \
            sum(1 for x in is_moving_block if x)) * self.tracking_mat[0:self.for_slicing, 1][is_moving_block]#!
        hop_length[not_moving_block] = 0
        self.tracking_mat[0:self.for_slicing, 0] = self.tracking_mat[0:self.for_slicing, 0] + hop_length #adds hop length to downstream distance #!
        hop_length[:] = 0
    
    def erode_blocks(self, is_block_in_cell, x):
        excess_block_tau = (self.uncorrected_tau_array[x] - self.corrected_tau_array[x] - self.tau_c_block)
        if excess_block_tau < 0:
            excess_block_tau = 0
        else:
            pass
        self.tracking_mat[0:self.for_slicing, 1][is_block_in_cell] -= self.ke_br_block * excess_block_tau * self.time_step#!
        self.tracking_mat[0:self.for_slicing, 1][is_block_in_cell] = self.tracking_mat[0:self.for_slicing, 1][is_block_in_cell].clip(min = 0) #no negative blocks #!
        self.tracking_mat[0:self.for_slicing, 2][is_block_in_cell] = np.power(self.tracking_mat[0:self.for_slicing, 1][is_block_in_cell], 3)  #!
            
    def calc_cover_frac(self, is_block_in_cell, x):
        block_cover = sum(np.power(self.tracking_mat[0:self.for_slicing, 1][is_block_in_cell], 2)) #area covered by blocks    #! 
        cover_frac = block_cover / (self.dx * self.channel_width) #how much of cell is COVERED by big bits
        self.cover_frac_array[x] = 1 - np.exp(-cover_frac)
        #get number of blocks in cell for plotting
        self.blocks_in_cells[x] = sum(is_block_in_cell)
        
    def get_block_size_classes(self, is_block_in_cell, x):
        sizes = self.tracking_mat[0:self.for_slicing, 1][is_block_in_cell] #!
        if np.isnan(np.sum(sizes)):
            print sizes
            print self.tracking_mat[:, 1] #!
            sys.exit("NAN FOUND IN SIZES ARRAY-- KILLING MODEL")
        self.zero_to_one_temp[x] = sum(sizes[sizes <= 1])
        self.one_to_two_temp[x] = sum(sizes[(sizes > 1) & (sizes <= 2)])
        self.two_to_three_temp[x] = sum(sizes[(sizes > 2) & (sizes <= 3)])
        self.three_to_four_temp[x] = sum(sizes[(sizes > 3) & (sizes <= 4)])
        self.four_to_five_temp[x] = sum(sizes[(sizes > 4) & (sizes <= 5)])
        self.five_to_six_temp[x] = sum(sizes[(sizes > 5) & (sizes <= 6)])
        self.six_to_seven_temp[x] = sum(sizes[(sizes > 5) & (sizes <= 6)])
        self.seven_to_eight_temp[x] = sum(sizes[(sizes > 5) & (sizes <= 6)])
        self.eight_to_nine_temp[x] = sum(sizes[(sizes > 5) & (sizes <= 6)])
        self.nine_to_ten_temp[x] = sum(sizes[(sizes > 5) & (sizes <= 6)])
        
    def track_vertical_erosion(self):
        self.incision_rate_array = abs(self.surface_elev_array - self.old_surf_elev_array)/ self.time_step
        self.incision_memory = np.roll(self.incision_memory, 1, 0)
        self.incision_memory[0, :] = self.incision_rate_array
        self.old_surf_elev_array[:] = self.surface_elev_array #update old, for incision rate calculations
        
#    def display_model_progress(self):
#        if self.run_count == 1 or np.remainder(self.run_count, 1000) == 0:
#            print 'Run ' + str(self.run_count) + ' of ' + str(self.number_iterations)
#            print self.blocks
#        else: 
#            pass
        
    def update_slope(self):
        self.slope[0:-1] = -(self.surface_elev_array[1:] - self.surface_elev_array[0:-1]) / (self.dx)
        self.slope[-1] = self.initial_slope 
        
    def update_record_keeping_arrays(self):
        self.record_count += 1            
        self.surface_elev_record[self.record_count, :] = self.surface_elev_array
        self.slope_record[self.record_count, :] = self.slope
        self.uncorrected_tau_record[self.record_count, :] = self.uncorrected_tau_array
        self.corrected_tau_record[self.record_count, :] = self.corrected_tau_array
        self.time_avg_inc_rate_record[self.record_count, :] = self.time_avg_inc_rate_array
        self.block_count_record[self.record_count, :] = self.blocks_in_cells
        self.cover_frac_record[self.record_count, :] = self.cover_frac_array
        self.one_to_two[self.record_count, :] = self.one_to_two_temp
        self.two_to_three[self.record_count, :] = self.two_to_three_temp
        self.three_to_four[self.record_count, :] = self.three_to_four_temp
        self.four_to_five[self.record_count, :] = self.four_to_five_temp
        self.five_to_six[self.record_count, :] = self.five_to_six_temp
        self.six_to_seven[self.record_count, :] = self.six_to_seven_temp
        self.seven_to_eight[self.record_count, :] = self.seven_to_eight_temp
        self.eight_to_nine[self.record_count, :] = self.eight_to_nine_temp
        self.nine_to_ten[self.record_count, :] = self.nine_to_ten_temp
        
    def delete_eroded_or_gone_blocks(self):
        #now find and delete any tracking rows where blocks have degraded to 0.
        for_abrasion_deletion = np.where(self.tracking_mat[:, 1] == 0)[0] #for_deletion is an array of vertical indices #!
        self.tracking_mat = np.delete(self.tracking_mat, for_abrasion_deletion, axis = 0) #deletes relevant rows
        
        #now find and delete any tracking rows where blocks have left domain
        for_transport_deletion = np.where(self.tracking_mat[:, 0] > self.downstream_edges_of_cell[-1])[0] #!
        self.tracking_mat = np.delete(self.tracking_mat, for_transport_deletion, axis = 0)
